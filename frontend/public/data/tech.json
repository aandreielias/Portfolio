[
    {
        "id": "3d-viewer",
        "title": "3D Model Viewer",
        "language": "svelte",
        "description": "A 3D model viewer showcasing a high-fidelity scan of the 'Marble head of Herakles'. This interactive viewer features smooth orbit controls for rotation and zooming, along with adjustable lighting to highlight surface details. <br><br>\"Marble head of Herakles\" (https://skfb.ly/oQVrB) by danielpett is licensed under Creative Commons Attribution (http://creativecommons.org/licenses/by/4.0/).",
        "files": {
            "ModelRenderer.svelte": "/uploads/tech/3d-viewer/ModelRenderer.svelte"
        }
    },
    {
        "id": "StockViewer",
        "title": "Live Market Viewer",
        "language": "javascript",
        "description": "A real-time market viewer for major digital assets, featuring live price updates, 24h trend indicators, and a dynamic history chart. Built with Svelte and the CoinGecko API for efficient, serverless data fetching.",
        "files": {
            "viewer.js": "// Live Market Viewer - Logic\n// Uses CoinGecko API for real-time market data & 24h history\n// Version 2.0 - Added Universal Search & Interactive Graph\n\nclass MarketViewer {\n    constructor() {\n        this.baseUrl = \"https://api.coingecko.com/api/v3\";\n        this.selectedSymbol = \"bitcoin\";\n    }\n\n    // New: Universal Search Function\n    async search(query) {\n        if (!query || query.length < 2) return [];\n        try {\n            const res = await fetch(`${this.baseUrl}/search?query=${query}`);\n            const data = await res.json();\n            return data.coins || [];\n        } catch (error) {\n            console.error(\"Search Error:\", error);\n            return [];\n        }\n    }\n\n    // Fetch 24-hour historical data for the chart\n    async fetchChart(id) {\n        try {\n            const response = await fetch(\n                `${this.baseUrl}/coins/${id}/market_chart?vs_currency=usd&days=1`\n            );\n            if (!response.ok) throw new Error(\"API Limit Reached\");\n            \n            const data = await response.json();\n            // Data format: [[timestamp, price], [timestamp, price], ...]\n            return data.prices || [];\n        } catch (error) {\n            console.error(\"Chart Fetch Error:\", error);\n            return [];\n        }\n    }\n    \n    // Fetch current price and 24h stats\n    async fetchCurrentStats(id) {\n        try {\n            const response = await fetch(\n                `${this.baseUrl}/simple/price?ids=${id}&vs_currencies=usd&include_24hr_change=true`\n            );\n            const data = await response.json();\n            return data[id] || null;\n        } catch (error) {\n            console.error(\"Stats Fetch Error:\", error);\n            return null;\n        }\n    }\n\n    // Main refresh loop\n    async refresh(id) {\n        const [history, stats] = await Promise.all([\n            this.fetchChart(id),\n            this.fetchCurrentStats(id)\n        ]);\n        \n        return {\n            history,\n            currentPrice: stats.usd,\n            change24h: stats.usd_24h_change\n        };\n    }\n}\n"
        }
    },
    {
        "id": "DashboardSim",
        "title": "DashboardSim",
        "language": "python",
        "description": "A high-fidelity Python simulation of a 2005 VW Phaeton W12 LWB. This project models the complex interaction between the 6.0L W12 engine, ZF 5HP24A automatic transmission, and the vehicle's chassis dynamics. It includes a real-time thermodynamic system, fluid dynamics for the torque converter, and a fully functional digital dashboard interface built with Tkinter.",
        "files": {
            "dashboard.py": "import tkinter as tk\nimport math\nimport time\nfrom simulator import Simulator\n\nclass DashboardApp:\n    def __init__(self, root):\n        self.root = root\n        self.root.title(\"Dashboard Simulator\")\n        self.root.geometry(\"1280x720\") # HD Resolution\n        self.root.configure(bg=\"#2a2a2a\")\n\n        # Initialize Simulator\n        self.sim = Simulator()\n        self.last_time = time.time()\n        self.last_screen_update = time.time() # Timer for the center screen\n        \n        # --- MFD (Multi-Function Display) State ---\n        self.page_index = 0\n        self.pages = [\"MAIN\", \"TRIP\", \"PERFORMANCE\", \"DIAGNOSTICS\"]\n        \n        # --- Needle Smoothing State ---\n        self.needle_values = {\n            'rpm': 0.8, 'speed': 0.0, 'oil': 15.0, \n            'coolant': 20.0, 'fuel': 1.0, 'batt': 12.0\n        }\n\n        # Canvas Setup\n        self.canvas = tk.Canvas(root, width=1280, height=550, bg=\"#2a2a2a\", highlightthickness=0)\n        self.canvas.pack(fill=tk.BOTH, expand=True)\n\n        # Pedal UI\n        self.pedal_frame = tk.Frame(root, bg=\"#151515\", height=170)\n        self.pedal_frame.pack(fill=tk.X, side=tk.BOTTOM)\n\n        # Container for centering pedals\n        self.pedal_container = tk.Frame(self.pedal_frame, bg=\"#151515\")\n        self.pedal_container.pack(side=tk.TOP, pady=15)\n        \n        # --- Pedal Controls ---\n        self.brake_canvas = tk.Canvas(self.pedal_container, width=120, height=140, bg=\"#151515\", highlightthickness=0)\n        self.brake_canvas.pack(side=tk.LEFT, padx=20)\n        self.draw_pedal(self.brake_canvas, \"BRAKE\\n(Down Arrow)\", \"#882222\")\n        self.brake_mouse_active = False\n\n        self.gas_canvas = tk.Canvas(self.pedal_container, width=100, height=140, bg=\"#151515\", highlightthickness=0)\n        self.gas_canvas.pack(side=tk.LEFT, padx=20)\n        self.draw_pedal(self.gas_canvas, \"GAS\\n(Up Arrow)\", \"#228822\")\n        self.gas_mouse_active = False\n\n        # --- Input State ---\n        self.key_gas = False\n        self.key_brake = False\n\n        # Bindings\n        self.brake_canvas.bind(\"<ButtonPress-1>\", lambda e: self.set_mouse_pedal('brake', True))\n        self.brake_canvas.bind(\"<ButtonRelease-1>\", lambda e: self.set_mouse_pedal('brake', False))\n        self.gas_canvas.bind(\"<ButtonPress-1>\", lambda e: self.set_mouse_pedal('gas', True))\n        self.gas_canvas.bind(\"<ButtonRelease-1>\", lambda e: self.set_mouse_pedal('gas', False))\n\n        self.root.bind(\"<KeyPress-Up>\", lambda e: self.set_key_pedal('gas', True))\n        self.root.bind(\"<KeyRelease-Up>\", lambda e: self.set_key_pedal('gas', False))\n        self.root.bind(\"<KeyPress-Down>\", lambda e: self.set_key_pedal('brake', True))\n        self.root.bind(\"<KeyRelease-Down>\", lambda e: self.set_key_pedal('brake', False))\n        \n        self.root.bind(\"<space>\", self.toggle_page)\n        self.root.focus_force()\n\n        self.update_loop()\n\n    def toggle_page(self, event):\n        self.page_index = (self.page_index + 1) % len(self.pages)\n\n    def set_mouse_pedal(self, pedal, state):\n        if pedal == 'brake': self.brake_mouse_active = state\n        elif pedal == 'gas': self.gas_mouse_active = state\n        self.update_pedal_visuals()\n\n    def set_key_pedal(self, pedal, state):\n        if pedal == 'brake': self.key_brake = state\n        elif pedal == 'gas': self.key_gas = state\n        self.update_pedal_visuals()\n\n    def update_pedal_visuals(self):\n        is_brake = self.brake_mouse_active or self.key_brake\n        color_b = \"#ff4444\" if is_brake else \"#882222\"\n        self.draw_pedal(self.brake_canvas, \"BRAKE\\n(Down Arrow)\", color_b)\n\n        is_gas = self.gas_mouse_active or self.key_gas\n        color_g = \"#44ff44\" if is_gas else \"#228822\"\n        self.draw_pedal(self.gas_canvas, \"GAS\\n(Up Arrow)\", color_g)\n\n    def draw_pedal(self, canvas, text, color):\n        canvas.delete(\"all\")\n        w = int(canvas.cget(\"width\"))\n        h = int(canvas.cget(\"height\"))\n        canvas.create_rectangle(5, 5, w-5, h-5, fill=color, outline=\"#aaaaaa\", width=2)\n        canvas.create_text(w/2, h/2, text=text, fill=\"white\", font=(\"Arial\", 10, \"bold\"), justify=tk.CENTER)\n\n    # --- Icon Drawing Methods ---\n    def draw_oil_icon(self, x, y, size=24, color=\"#888\"):\n        self.canvas.create_polygon(x-size/2, y+size/2, x+size/2, y+size/2, x+size/2, y-size/4, x-size/2, y-size/4, fill=color, outline=color)\n        self.canvas.create_line(x+size/2, y-size/5, x+size, y-size/2, width=2, fill=color)\n        self.canvas.create_line(x-size/2, y, x-size, y-size/2, x-size/2, y-size/4, width=2, fill=color)\n        self.canvas.create_oval(x+size, y-size/2, x+size+4, y-size/2+4, fill=color, outline=\"\")\n\n    def draw_temp_icon(self, x, y, size=24, color=\"#888\"):\n        self.canvas.create_line(x, y-size/2, x, y+size/4, width=5, fill=color, capstyle=tk.ROUND)\n        self.canvas.create_oval(x-5, y+size/4-5, x+5, y+size/4+5, fill=color, outline=\"\")\n        self.canvas.create_line(x+5, y-6, x+10, y-6, fill=color, width=2)\n        self.canvas.create_line(x+5, y+2, x+10, y+2, fill=color, width=2)\n\n    def draw_fuel_icon(self, x, y, size=24, color=\"#888\"):\n        self.canvas.create_rectangle(x-6, y-10, x+6, y+10, outline=color, width=2)\n        self.canvas.create_rectangle(x-4, y-8, x+4, y-3, fill=color, outline=\"\")\n        self.canvas.create_line(x+6, y, x+10, y, x+10, y+12, x-10, y+12, x-10, y-10, width=2, fill=color)\n        self.canvas.create_line(x-10, y-10, x-6, y-10, width=2, fill=color)\n\n    def draw_battery_icon(self, x, y, size=24, color=\"#888\"):\n        self.canvas.create_rectangle(x-10, y-6, x+10, y+6, outline=color, width=2)\n        self.canvas.create_rectangle(x-5, y-9, x-3, y-6, fill=color, outline=\"\")\n        self.canvas.create_rectangle(x+3, y-9, x+5, y-6, fill=color, outline=\"\")\n        self.canvas.create_text(x-6, y, text=\"-\", fill=color, font=(\"Arial\", 10, \"bold\"))\n        self.canvas.create_text(x+6, y, text=\"+\", fill=color, font=(\"Arial\", 8, \"bold\"))\n\n    def draw_gauge_background(self, x, y, r, min_val, max_val, title, major_ticks, unit=\"\", icon_type=None):\n        self.canvas.create_oval(x-r-2, y-r-2, x+r+2, y+r+2, outline=\"#888888\", width=3)\n        self.canvas.create_oval(x-r, y-r, x+r, y+r, outline=\"#555555\", width=5)\n        self.canvas.create_oval(x-r+5, y-r+5, x+r-5, y+r-5, fill=\"#050505\", outline=\"\")\n        \n        for i in range(major_ticks + 1):\n            val = min_val + (max_val - min_val) * (i / major_ticks)\n            sim_angle = 225 - (270 * (i / major_ticks))\n            rad = math.radians(sim_angle)\n            \n            tick_r_out = r - 10\n            tick_r_in = r - 25\n            \n            tx1 = x + tick_r_in * math.cos(rad)\n            ty1 = y - tick_r_in * math.sin(rad)\n            tx2 = x + tick_r_out * math.cos(rad)\n            ty2 = y - tick_r_out * math.sin(rad)\n            \n            self.canvas.create_line(tx1, ty1, tx2, ty2, fill=\"white\", width=2)\n            \n            text_r = r - 40\n            tx = x + text_r * math.cos(rad)\n            ty = y - text_r * math.sin(rad)\n            font_size = 10 if r > 80 else 8\n            self.canvas.create_text(tx, ty, text=str(int(val)), fill=\"white\", font=(\"Arial\", font_size))\n\n        if icon_type:\n            if icon_type == \"oil\": self.draw_oil_icon(x, y - r/2.5)\n            elif icon_type == \"temp\": self.draw_temp_icon(x, y - r/2.5)\n            elif icon_type == \"fuel\": self.draw_fuel_icon(x, y - r/2.5)\n            elif icon_type == \"batt\": self.draw_battery_icon(x, y - r/2.5)\n        else:\n            self.canvas.create_text(x, y + r/2 + 5, text=title, fill=\"#aaaaaa\", font=(\"Arial\", 12, \"bold\"))\n            self.canvas.create_text(x, y + r/2 + 25, text=unit, fill=\"#888888\", font=(\"Arial\", 10))\n\n    def update_needle(self, tag, x, y, r, val, min_val, max_val):\n        self.canvas.delete(tag)\n        val = max(min_val, min(max_val, val))\n        pct = (val - min_val) / (max_val - min_val)\n        angle_deg = 225 - (270 * pct)\n        rad = math.radians(angle_deg)\n        \n        tip_r = r - 15\n        tx = x + tip_r * math.cos(rad)\n        ty = y - tip_r * math.sin(rad)\n        \n        self.canvas.create_line(x, y, tx, ty, fill=\"#ff2222\", width=4, tags=tag, capstyle=tk.ROUND)\n        self.canvas.create_oval(x-7, y-7, x+7, y+7, fill=\"#111\", outline=\"#555\", tags=tag)\n\n    def draw_center_screen_static(self):\n        # 200px wide screen\n        x1, y1 = 540, 150\n        x2, y2 = 740, 350\n        \n        self.canvas.create_rectangle(x1-4, y1-4, x2+4, y2+4, outline=\"#444\", width=3)\n        self.canvas.create_rectangle(x1, y1, x2, y2, fill=\"black\", outline=\"\")\n        \n        self.canvas.create_text(640, y1+20, text=\"PRNDS\", fill=\"#555\", font=(\"Courier\", 12, \"bold\"))\n        self.canvas.create_line(x1+10, y1+35, x2-10, y1+35, fill=\"#333\")\n        self.canvas.create_text(640, y2+15, text=\"[SPACE] Change Page\", fill=\"#555\", font=(\"Arial\", 8))\n\n    def update_center_screen(self, stats):\n        self.canvas.delete(\"screen_data\")\n        \n        page = self.pages[self.page_index]\n        self.canvas.create_text(640, 150 + 45, text=f\"- {page} -\", fill=\"#888\", font=(\"Arial\", 9, \"bold\"), tags=\"screen_data\")\n\n        if page == \"MAIN\":\n            self.canvas.create_text(640, 230, text=str(stats['gear']), fill=\"orange\", font=(\"Courier\", 45, \"bold\"), tags=\"screen_data\")\n            self.canvas.create_text(640, 205, text=\"GEAR\", fill=\"#555\", font=(\"Arial\", 8), tags=\"screen_data\")\n            self.canvas.create_text(640, 280, text=f\"{stats['speed_kmh']}\", fill=\"white\", font=(\"Courier\", 26, \"bold\"), tags=\"screen_data\")\n            self.canvas.create_text(640, 300, text=\"km/h\", fill=\"#aaa\", font=(\"Arial\", 8), tags=\"screen_data\")\n            cons = f\"{stats['fuel_usage_l_100km']} L/100\" if stats['speed_kmh'] > 5 else \"--.- L/100\"\n            self.canvas.create_text(640, 330, text=cons, fill=\"#aaa\", font=(\"Courier\", 10), tags=\"screen_data\")\n\n        elif page == \"TRIP\":\n            self.canvas.create_text(640, 215, text=\"RANGE\", fill=\"#555\", font=(\"Arial\", 8), tags=\"screen_data\")\n            self.canvas.create_text(640, 230, text=f\"{stats['range_km']} km\", fill=\"#4f4\", font=(\"Courier\", 16, \"bold\"), tags=\"screen_data\")\n            self.canvas.create_text(640, 260, text=\"ODOMETER\", fill=\"#555\", font=(\"Arial\", 8), tags=\"screen_data\")\n            self.canvas.create_text(640, 275, text=f\"{int(stats['odometer_km'])} km\", fill=\"white\", font=(\"Courier\", 12), tags=\"screen_data\")\n            self.canvas.create_text(640, 305, text=\"AFR\", fill=\"#555\", font=(\"Arial\", 8), tags=\"screen_data\")\n            self.canvas.create_text(640, 320, text=f\"{stats['afr']}:1\", fill=\"cyan\", font=(\"Courier\", 12), tags=\"screen_data\")\n\n        elif page == \"PERFORMANCE\":\n            self.canvas.create_text(600, 220, text=\"HP\", fill=\"#555\", font=(\"Arial\", 8), tags=\"screen_data\")\n            self.canvas.create_text(600, 235, text=f\"{stats['power_hp']}\", fill=\"orange\", font=(\"Courier\", 14, \"bold\"), tags=\"screen_data\")\n            self.canvas.create_text(680, 220, text=\"TRQ\", fill=\"#555\", font=(\"Arial\", 8), tags=\"screen_data\")\n            self.canvas.create_text(680, 235, text=f\"{stats['torque_nm']}\", fill=\"orange\", font=(\"Courier\", 14, \"bold\"), tags=\"screen_data\")\n            self.canvas.create_text(640, 265, text=f\"G-FORCE: {stats['accel_g']} G\", fill=\"white\", font=(\"Courier\", 12), tags=\"screen_data\")\n            self.canvas.create_text(640, 300, text=\"0-100 km/h\", fill=\"#555\", font=(\"Arial\", 8), tags=\"screen_data\")\n            timer_col = \"red\" if stats['timer_0_100'] > 0 else \"#444\"\n            if stats['best_0_100'] > 0: timer_col = \"#4f4\"\n            disp_time = stats['timer_0_100'] if stats['timer_0_100'] > 0 else stats['best_0_100']\n            self.canvas.create_text(640, 315, text=f\"{disp_time} s\", fill=timer_col, font=(\"Courier\", 14, \"bold\"), tags=\"screen_data\")\n\n        elif page == \"DIAGNOSTICS\":\n            self.canvas.create_text(590, 220, text=\"TRANS TEMP\", fill=\"#555\", font=(\"Arial\", 7), tags=\"screen_data\")\n            self.canvas.create_text(590, 235, text=f\"{stats['trans_temp']}\u00b0C\", fill=\"white\", font=(\"Courier\", 11), tags=\"screen_data\")\n            self.canvas.create_text(690, 220, text=\"INTAKE AIR\", fill=\"#555\", font=(\"Arial\", 7), tags=\"screen_data\")\n            self.canvas.create_text(690, 235, text=f\"{stats['iat_temp']}\u00b0C\", fill=\"white\", font=(\"Courier\", 11), tags=\"screen_data\")\n            self.canvas.create_text(590, 270, text=\"CONV. SLIP\", fill=\"#555\", font=(\"Arial\", 7), tags=\"screen_data\")\n            self.canvas.create_text(590, 285, text=f\"{stats['slip_rpm']}\", fill=\"orange\", font=(\"Courier\", 11), tags=\"screen_data\")\n            self.canvas.create_text(690, 270, text=\"LOCKUP\", fill=\"#555\", font=(\"Arial\", 7), tags=\"screen_data\")\n            status = \"CLOSED\" if stats['lockup'] else \"OPEN\"\n            col = \"#4f4\" if stats['lockup'] else \"#f44\"\n            self.canvas.create_text(690, 285, text=status, fill=col, font=(\"Courier\", 10, \"bold\"), tags=\"screen_data\")\n            self.canvas.create_text(640, 315, text=f\"OIL P: {stats['oil_pressure']} bar\", fill=\"#aaa\", font=(\"Courier\", 10), tags=\"screen_data\")\n\n    def smooth_value(self, key, target, max_change_rate, dt):\n        current = self.needle_values.get(key, target)\n        diff = target - current\n        max_step = max_change_rate * dt\n        if abs(diff) <= max_step: self.needle_values[key] = target\n        else: self.needle_values[key] += math.copysign(max_step, diff)\n        return self.needle_values[key]\n\n    def update_loop(self):\n        current_time = time.time()\n        dt = current_time - self.last_time\n        self.last_time = current_time\n        \n        throttle_input = 1.0 if (self.gas_mouse_active or self.key_gas) else 0.0\n        brake_input = 1.0 if (self.brake_mouse_active or self.key_brake) else 0.0\n        \n        self.sim.set_inputs(throttle_input, brake_input)\n        stats = self.sim.update(dt)\n        \n        if not hasattr(self, 'gauges_initialized'):\n            self.canvas.delete(\"all\")\n            self.draw_gauge_background(360, 280, 140, 0, 8, \"x1000\", 8, unit=\"RPM\")\n            self.draw_gauge_background(920, 280, 140, 0, 320, \"km/h\", 8)\n            self.draw_gauge_background(140, 360, 75, 50, 150, \"OIL\", 2, unit=\"\u00b0C\", icon_type=\"oil\")\n            self.draw_gauge_background(1140, 360, 75, 8, 16, \"BATT\", 2, unit=\"V\", icon_type=\"batt\")\n            self.draw_gauge_background(570, 430, 45, 50, 130, \"ENGINE\", 2, icon_type=\"temp\")\n            self.draw_gauge_background(710, 430, 45, 0, 1, \"FUEL\", 2, icon_type=\"fuel\")\n            self.draw_center_screen_static()\n            self.gauges_initialized = True\n\n        # Needles Smooth Logic\n        val_rpm = self.smooth_value('rpm', stats['rpm']/1000, 8.0, dt)\n        val_speed = self.smooth_value('speed', stats['speed_kmh'], 160.0, dt)\n        val_oil = self.smooth_value('oil', stats['oil_temp'], 10.0, dt)\n        val_coolant = self.smooth_value('coolant', stats['engine_temp'], 10.0, dt)\n        val_fuel = self.smooth_value('fuel', stats['fuel_ltr']/90.0, 0.05, dt)\n        target_volts = 11.5 + (stats['battery_pct']/100 * 3.0)\n        val_batt = self.smooth_value('batt', target_volts, 2.0, dt)\n\n        self.update_needle(\"needle_rpm\", 360, 280, 140, val_rpm, 0, 8)\n        self.update_needle(\"needle_speed\", 920, 280, 140, val_speed, 0, 320)\n        self.update_needle(\"needle_oil\", 140, 360, 75, val_oil, 50, 150)\n        self.update_needle(\"needle_batt\", 1140, 360, 75, val_batt, 8, 16)\n        self.update_needle(\"needle_coolant\", 570, 430, 45, val_coolant, 50, 130)\n        self.update_needle(\"needle_fuel\", 710, 430, 45, val_fuel, 0, 1)\n\n        # Update center screen only 4 times per second (every 0.25s)\n        if current_time - self.last_screen_update >= 0.25:\n             self.update_center_screen(stats)\n             self.last_screen_update = current_time\n\n        self.root.after(30, self.update_loop)\n\nif __name__ == \"__main__\":\n    root = tk.Tk()\n    app = DashboardApp(root)\n    root.mainloop()",
            "simulator.py": "import time\nimport math\n\nclass Simulator:\n    def __init__(self):\n        # --- Inputs ---\n        self.throttle = 0.0\n        self.brake = 0.0\n        self.prev_throttle = 0.0\n\n        # --- State Variables ---\n        self.speed_mps = 0.0\n        self.rpm = 800.0\n        self.gear = 1\n        self.mode = 'DRIVE'\n        \n        # --- Consumables ---\n        self.fuel_liters = 90.0\n        self.battery_lvl = 100.0\n        \n        # --- Trip & Efficiency Data ---\n        self.odometer_km = 0.0\n        self.current_fuel_rate_l_h = 0.0\n        self.avg_fuel_consumption = 15.0\n        self.current_afr = 14.7\n        self.range_km = 0.0\n        \n        # --- Performance Metrics ---\n        self.torque_net_nm = 0.0\n        self.power_hp = 0.0\n        self.accel_g = 0.0\n        self.timer_0_100 = 0.0\n        self.best_0_100 = 0.0\n        self.is_doing_0_100 = False\n        \n        # --- Advanced Thermodynamics State (Celsius) ---\n        self.temp_coolant = 20.0\n        self.temp_oil = 20.0\n        self.temp_trans = 20.0\n        self.temp_block = 20.0\n        self.temp_cabin = 20.0\n        self.temp_ambient = 15.0\n        self.temp_intake = 15.0\n\n        # --- Mechanics Constants (2005 VW Phaeton W12 LWB) ---\n        self.mass_kg = 2450.0\n        self.drag_coeff = 0.32\n        self.frontal_area = 2.40\n        self.tire_radius = 0.35\n        self.tire_circumference = 2.0 * math.pi * self.tire_radius\n        self.rolling_resistance_c = 0.012\n        \n        # --- Engine Constants ---\n        self.displacement = 6.0\n        self.idle_rpm = 600.0\n        self.redline_rpm = 6200.0\n        # INCREASED INERTIA: W12 Crank + Flywheel + Converter fluid mass is heavy.\n        # This prevents the \"wonky\" oscillation at low gears.\n        self.inertia_engine = 0.65 \n        \n        # --- Transmission Constants (ZF 5HP24A) ---\n        self.gear_ratios = {1: 3.57, 2: 2.20, 3: 1.51, 4: 1.00, 5: 0.80}\n        self.final_drive = 3.07\n        self.shift_point_up = 5900\n        self.shift_point_down = 1100\n        self.lockup_active = False\n        self.converter_slip_rpm = 0.0\n        self.volumetric_efficiency = 0.0\n\n    def set_inputs(self, throttle, brake):\n        self.prev_throttle = self.throttle\n        self.throttle = max(0.0, min(1.0, throttle))\n        self.brake = max(0.0, min(1.0, brake))\n\n    # =========================================================================\n    # CORE PHYSICS MODULES\n    # =========================================================================\n\n    def _get_air_density(self):\n        temp_kelvin = self.temp_intake + 273.15\n        return 1.225 * (288.15 / temp_kelvin)\n\n    def _get_torque_curve(self, rpm):\n        if rpm < 600: return 200\n        if rpm < 2750:\n            factor = (rpm - 600) / (2750 - 600)\n            return 300 + (260 * factor)\n        elif rpm <= 5200:\n            return 560\n        elif rpm <= 6500:\n            factor = (rpm - 5200) / (6500 - 5200)\n            return 560 - (100 * factor)\n        return 0\n\n    def _get_volumetric_efficiency(self, rpm, throttle):\n        ve_rpm = 0.85 + 0.15 * (1 - ((rpm - 4000)/3500)**2)\n        ve_load = 0.15 + (0.85 * throttle)\n        return max(0.1, ve_rpm * ve_load)\n\n    # =========================================================================\n    # DYNAMICS LOOPS\n    # =========================================================================\n\n    def _calculate_engine_kinetics(self, dt, load_torque_nm):\n        # 1. Combustion Torque\n        max_torque = self._get_torque_curve(self.rpm)\n        actual_torque = max_torque * self.throttle\n        \n        # 2. Friction\n        friction_torque = 20.0 + (self.rpm / 6000.0)**2 * 60.0\n        if self.throttle < 0.05:\n            vacuum_drag = (self.rpm / 3000.0) * 40.0\n            friction_torque += vacuum_drag\n\n        # 3. Net Torque & RPM\n        self.torque_net_nm = actual_torque - friction_torque - load_torque_nm\n        \n        alpha = self.torque_net_nm / self.inertia_engine\n        rpm_change = (alpha * dt) * (60.0 / (2.0 * math.pi))\n        \n        self.rpm += rpm_change\n        self.rpm = max(0, min(self.rpm, self.redline_rpm + 200))\n        \n        self.power_hp = (actual_torque * self.rpm) / 7120.0\n\n    def _calculate_chassis_kinetics(self, dt, drive_force_n):\n        rho = self._get_air_density()\n        f_aero = 0.5 * rho * self.drag_coeff * self.frontal_area * (self.speed_mps ** 2)\n        f_roll = self.rolling_resistance_c * self.mass_kg * 9.81\n        f_brake = self.brake * 18000.0\n        f_mech = self.speed_mps * 10.0\n        \n        f_net = drive_force_n - f_aero - f_roll - f_brake - f_mech\n        \n        if self.speed_mps <= 0.01 and f_net < 0:\n            f_net = 0\n            self.speed_mps = 0\n            \n        accel = f_net / self.mass_kg\n        self.speed_mps += accel * dt\n        if self.speed_mps < 0: self.speed_mps = 0\n        \n        self.accel_g = accel / 9.81\n        dist_km = (self.speed_mps * dt) / 1000.0\n        self.odometer_km += dist_km\n        \n        # 0-100 Logic\n        speed_kmh = self.speed_mps * 3.6\n        if speed_kmh < 1.0:\n            self.is_doing_0_100 = False\n            self.timer_0_100 = 0.0\n        elif speed_kmh > 1.0 and speed_kmh < 100.0:\n            if not self.is_doing_0_100 and self.accel_g > 0.1:\n                self.is_doing_0_100 = True\n            if self.is_doing_0_100:\n                self.timer_0_100 += dt\n        elif speed_kmh >= 100.0 and self.is_doing_0_100:\n            self.best_0_100 = self.timer_0_100\n            self.is_doing_0_100 = False\n\n    def _update_thermodynamics(self, dt):\n        c_iron = 450; m_block = 200.0 \n        c_water = 4184; m_coolant = 15.0\n        c_oil = 1800; m_oil = 12.0\n        c_atf = 2000; m_atf = 10.0\n        \n        heat_in_watts = self.current_fuel_rate_l_h * 150 \n        \n        k_block_coolant = 50.0 + (self.rpm / 6000.0) * 300.0\n        q_block_coolant = k_block_coolant * (self.temp_block - self.temp_coolant)\n        \n        k_block_oil = 20.0 + (self.rpm / 6000.0) * 80.0\n        q_block_oil = k_block_oil * (self.temp_block - self.temp_oil)\n        \n        airflow = 5.0 + (self.speed_mps * 2.0)\n        thermostat = max(0.05, min(1.0, (self.temp_coolant - 82) / 10.0))\n        k_radiator = thermostat * airflow * 50.0\n        q_coolant_air = k_radiator * (self.temp_coolant - self.temp_ambient)\n        \n        q_oil_cooler = 15.0 * (self.temp_oil - self.temp_coolant)\n        \n        slip_rad_s = (self.converter_slip_rpm * 2 * math.pi) / 60.0\n        q_trans_slip = abs(self.torque_net_nm * slip_rad_s) * 0.5\n        q_trans_cool = 20.0 * (self.temp_trans - self.temp_ambient) * (1 + self.speed_mps/10)\n        \n        target_iat = self.temp_ambient + (self.temp_block - self.temp_ambient) * 0.15\n        cooling_iat = (self.speed_mps + 1.0) * 0.1\n        self.temp_intake += (target_iat - self.temp_intake - cooling_iat) * 0.1 * dt\n        self.temp_intake = max(self.temp_ambient, self.temp_intake)\n\n        self.temp_block += ((heat_in_watts - q_block_coolant - q_block_oil) / (m_block * c_iron)) * dt\n        self.temp_coolant += ((q_block_coolant + q_oil_cooler - q_coolant_air) / (m_coolant * c_water)) * dt\n        self.temp_oil += ((q_block_oil - q_oil_cooler) / (m_oil * c_oil)) * dt\n        self.temp_trans += ((q_trans_slip - q_trans_cool) / (m_atf * c_atf)) * dt\n\n        viscosity = 100 * math.exp(-0.03 * (self.temp_oil - 20))\n        raw_pressure = (self.rpm * 0.002) * (viscosity * 0.05)\n        self.oil_pressure_bar = min(7.0, max(0.5, raw_pressure)) if self.rpm > 300 else 0\n        self.temp_cabin += (22.0 - self.temp_cabin) * 0.05 * dt\n\n    def _calculate_fuel(self, dt):\n        rho_air = self._get_air_density()\n        self.volumetric_efficiency = self._get_volumetric_efficiency(self.rpm, self.throttle)\n        \n        intake_flow_l_s = (self.rpm / 120.0) * self.displacement * self.volumetric_efficiency\n        air_mass_s = (intake_flow_l_s / 1000.0) * rho_air\n        \n        self.current_afr = 14.7\n        if self.throttle > 0.7: self.current_afr = 12.5\n        \n        if self.throttle < 0.01 and self.rpm > 1200:\n            fuel_mass_s = 0.0\n            self.current_afr = 99.9\n        else:\n            fuel_mass_s = air_mass_s / self.current_afr\n            \n        if (self.throttle - self.prev_throttle) > 0.1:\n            fuel_mass_s *= 1.5\n            \n        fuel_l_s = fuel_mass_s / 0.74\n        self.current_fuel_rate_l_h = fuel_l_s * 3600.0\n        self.fuel_liters = max(0, self.fuel_liters - (fuel_l_s * dt))\n        \n        speed_kmh = self.speed_mps * 3.6\n        if speed_kmh > 10 and fuel_l_s > 0:\n            current_l_100 = (self.current_fuel_rate_l_h / speed_kmh) * 100.0\n            self.avg_fuel_consumption = (self.avg_fuel_consumption * 0.995) + (current_l_100 * 0.005)\n            \n        if self.avg_fuel_consumption > 0.1:\n            self.range_km = (self.fuel_liters / self.avg_fuel_consumption) * 100.0\n        else:\n            self.range_km = 999.0\n            \n        draw = 0.02 * dt\n        gen = 0.06 * dt if self.rpm > 800 else 0\n        self.battery_lvl = min(100, max(0, self.battery_lvl - draw + gen))\n\n    # =========================================================================\n    # MAIN LOOP\n    # =========================================================================\n\n    def update(self, dt):\n        total_ratio = self.gear_ratios[self.gear] * self.final_drive\n        trans_out_rpm = (self.speed_mps / self.tire_circumference) * 60.0 * total_ratio\n        \n        # Torque Converter Physics\n        self.lockup_active = (self.gear >= 3 and self.speed_mps > 15)\n        \n        if self.lockup_active:\n            # Locked\n            target_rpm = max(self.idle_rpm, trans_out_rpm)\n            self.rpm = target_rpm\n            self.converter_slip_rpm = 0.0\n            \n            eng_torque = self._get_torque_curve(self.rpm) * self.throttle\n            if self.throttle < 0.01: eng_torque = -40.0 - (self.rpm/100)\n            drive_force = (eng_torque * total_ratio) / self.tire_radius\n            \n            self._calculate_engine_kinetics(dt, 0)\n            \n        else:\n            # Slipping\n            self.converter_slip_rpm = self.rpm - trans_out_rpm\n            \n            # Slightly softer coupling to prevent oscillation\n            k_converter = 0.0045 \n            \n            transfer_torque = math.copysign(1.0, self.converter_slip_rpm) * (self.converter_slip_rpm ** 2) * k_converter\n            max_transfer = self._get_torque_curve(self.rpm) * 2.5\n            load_torque = max(-max_transfer, min(max_transfer, transfer_torque))\n            \n            drive_force = (load_torque * total_ratio) / self.tire_radius\n            \n            self._calculate_engine_kinetics(dt, load_torque)\n            \n            # Idle Governor (Smoother P-Control)\n            if self.rpm < self.idle_rpm:\n                self.rpm += (self.idle_rpm - self.rpm) * 2.0 * dt\n\n        self._calculate_chassis_kinetics(dt, drive_force)\n        \n        if self.rpm > self.shift_point_up and self.gear < 5:\n            self.gear += 1\n        elif self.rpm < self.shift_point_down and self.gear > 1:\n            self.gear -= 1\n            self.rpm += 500\n            \n        self._update_thermodynamics(dt)\n        self._calculate_fuel(dt)\n        \n        speed_kmh = self.speed_mps * 3.6\n        fuel_100km = (self.current_fuel_rate_l_h / speed_kmh * 100.0) if speed_kmh > 1 else 0.0\n\n        return {\n            \"rpm\": int(self.rpm),\n            \"speed_kmh\": int(speed_kmh),\n            \"gear\": self.gear,\n            \"engine_temp\": round(self.temp_coolant, 1),\n            \"oil_temp\": round(self.temp_oil, 1),\n            \"oil_pressure\": round(self.oil_pressure_bar, 2),\n            \"trans_temp\": round(self.temp_trans, 1),\n            \"fuel_ltr\": round(self.fuel_liters, 2),\n            \"battery_pct\": round(self.battery_lvl, 1),\n            \"fuel_usage_l_100km\": round(min(99.9, fuel_100km), 1),\n            \"range_km\": int(self.range_km),\n            \"odometer_km\": round(self.odometer_km, 1),\n            \"afr\": round(self.current_afr, 1),\n            \"power_hp\": int(self.power_hp),\n            \"torque_nm\": int(self.torque_net_nm),\n            \"accel_g\": round(self.accel_g, 2),\n            \"timer_0_100\": round(self.timer_0_100, 1),\n            \"best_0_100\": round(self.best_0_100, 2),\n            \"iat_temp\": round(self.temp_intake, 1),\n            \"ve_pct\": int(self.volumetric_efficiency * 100),\n            \"slip_rpm\": int(self.converter_slip_rpm),\n            \"lockup\": self.lockup_active\n        }"
        }
    }
]